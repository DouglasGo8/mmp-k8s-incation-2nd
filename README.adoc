= Kubernetes in Action 2nd

== Links

- https://camel.apache.org/components/2.x/kubernetes-component.html[Apache Camel Kubernetes API]
- https://github.com/Apress/cloud-native-integration-apache-camel[Cloud Native Integration with Apache Camel Git Source]

== Introduction the Kubernetes API using Apache Camel Kubernetes API

.A K8s cluster objects
image::architecture/thumbs/api_k8s_interaction.jpg[]

* They include the applications running in the cluster, their configuration, the load balancers through which they are exposed within the cluster or externally, the underlying servers and the storage used by these applications, the security privileges of users and applications, and many other details of the infrastructure.
* The collection of all deployments in the cluster is a REST resource exposed at ##/api/v1/deployments##
* The Kubernetes Control Plane runs several components called controllers that manage the objects you create.
Each controller is usually only responsible for one object type.
For example, the Deployment controller manages Deployment objects.

[source,bash]
----
kubectl get notes
kubectl get node localhost -o yaml
----

* To use API we need expose the api

[source,bash]
----
kubectl proxy
----

== Running Application in Pods

.Three basic object types comprising a deployed application
image::architecture/thumbs/comprising_deploy_k8s_pod.jpg[]

. World -> Service -> Pods <- -> Deployment

. Pod object, represents the ##central and most important concept in K8s## - a running instance of your application, pod is a co-located group of containers and the basic building block in Kubernetes, in the K8s we don't deploy containers but groups of them managed as a single unit, ##When a Pod has multiple containers, all of them run on the same worker node##, a single pod instance never spans multiple nodes,
. Containers are _designed_ to run only a single process, to take full advantage of the features provided by the container runtime, you should consider running only one process in each container.
. With a pod, you can run closely related processes together, giving them (almost) the same environment as if they were all running in a single container, all containers in a pod share the same Network namespace and thus the network interfaces, IP address(es) and port space that belong to it.
Because of the shared port space, processes running in containers of the same pod canâ€™t be bound to the same port numbers, All the containers in a pod also see the same system hostname.
. Each pod can be considered as separated vCPu/Cpu, avoid stuffing all your applications into a single pod, you should divide them so that each pod runs only closely related application processes.
. ##Kubernetes does not replicate containers within a pod.
It replicates the entire pod.##
. You never need to combine multiple applications in a single pod


.Containers in a pod sharing the same Network namespace
image::architecture/thumbs/pod_share_same_network_interface.jpg[]

=== Sidecar Containers

. Several containers in a single pod is only appropriate if the application consists of a primary process and one or more processes that complement the operation of the primary process.

.Sidecar Container in same Pod
image::architecture/thumbs/sidecar.png[]

=== Create Pod Object
[source, bash]
----
kubectl apply -f basic-manifest.yaml
kubectl get pod quarkus-hello -o yaml
kubectl get pod quarkus-hello
kubectl get pod quarkus-hello -o wide
----